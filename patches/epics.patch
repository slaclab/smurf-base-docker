diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h	2016-12-13 05:25:23
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h	2025-04-30 01:08:02
@@ -88,8 +88,8 @@
 private:
     clientBufMemoryManager clientBufMemMgr;
     tsFreeList < casMonitor, 1024 > casMonitorFreeList;
-    tsDLList < casStrmClient > clientList;
-    tsDLList < casIntfOS > intfList;
+    ::tsDLList < casStrmClient > clientList;
+    ::tsDLList < casIntfOS > intfList;
     mutable epicsMutex mutex;
     mutable epicsMutex diagnosticCountersMutex;
     caServer & adapter;
diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h-e epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h-e
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h-e	1969-12-31 16:00:00
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/caServerI.h-e	2016-12-13 05:25:23
@@ -0,0 +1,176 @@
+
+/*************************************************************************\
+* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
+*     National Laboratory.
+* Copyright (c) 2002 The Regents of the University of California, as
+*     Operator of Los Alamos National Laboratory.
+* EPICS BASE Versions 3.13.7
+* and higher are distributed subject to a Software License Agreement found
+* in file LICENSE that is included with this distribution. 
+\*************************************************************************/
+
+#ifndef caServerIh
+#define caServerIh
+
+#ifdef epicsExportSharedSymbols
+#   define epicsExportSharedSymbols_caServerIh
+#   undef epicsExportSharedSymbols
+#endif
+
+// external headers included here
+#include "tsFreeList.h"
+#include "caProto.h"
+
+#ifdef epicsExportSharedSymbols_caServerIh
+#   define epicsExportSharedSymbols
+#   include "shareLib.h"
+#endif
+
+#include "casdef.h"
+#include "clientBufMemoryManager.h"
+#include "casEventRegistry.h"
+#include "caServerIO.h"
+#include "ioBlocked.h"
+#include "caServerDefs.h"
+
+class casStrmClient;
+class beaconTimer;
+class beaconAnomalyGovernor;
+class casIntfOS;
+class casMonitor;
+class casChannelI;
+
+caStatus convertContainerMemberToAtomic (class gdd & dd,
+         aitUint32 appType, aitUint32 requestedCount, aitUint32 nativeCount);
+
+// Keep the old signature for backward compatibility
+inline caStatus convertContainerMemberToAtomic (class gdd & dd,
+         aitUint32 appType, aitUint32 elemCount)
+{ return convertContainerMemberToAtomic(dd, appType, elemCount, elemCount); }
+
+class caServerI : 
+    public caServerIO, 
+    public ioBlockedList, 
+    public casEventRegistry {
+public:
+    caServerI ( caServer &tool );
+    ~caServerI ();
+    bool roomForNewChannel() const;
+    unsigned getDebugLevel() const { return debugLevel; }
+    inline void setDebugLevel ( unsigned debugLevelIn );
+    void show ( unsigned level ) const;
+    void destroyMonitor ( casMonitor & );
+    caServer * getAdapter ();
+    caServer * operator -> ();
+    void connectCB ( casIntfOS & );
+    casEventMask valueEventMask () const; // DBE_VALUE registerEvent("value")
+    casEventMask logEventMask () const;     // DBE_LOG registerEvent("log") 
+    casEventMask alarmEventMask () const; // DBE_ALARM registerEvent("alarm") 
+    casEventMask propertyEventMask () const; // DBE_PROPERTY registerEvent("property") 
+    unsigned subscriptionEventsProcessed () const;
+    void incrEventsProcessedCounter ();
+    unsigned subscriptionEventsPosted () const;
+    void updateEventsPostedCounter ( unsigned nNewPosts );
+    void generateBeaconAnomaly ();
+    casMonitor & casMonitorFactory ( casChannelI &, 
+        caResId clientId, const unsigned long count, 
+        const unsigned type, const casEventMask &, 
+        class casMonitorCallbackInterface & );
+    void casMonitorDestroy ( casMonitor & );
+    void destroyClient ( casStrmClient & );
+    static void dumpMsg ( 
+        const char * pHostName, const char * pUserName,
+        const struct caHdrLargeArray * mp, const void * dp, 
+        const char * pFormat, ... );
+    bool ioIsPending () const;
+    void incrementIOInProgCount ();
+    void decrementIOInProgCount ();
+private:
+    clientBufMemoryManager clientBufMemMgr;
+    tsFreeList < casMonitor, 1024 > casMonitorFreeList;
+    tsDLList < casStrmClient > clientList;
+    tsDLList < casIntfOS > intfList;
+    mutable epicsMutex mutex;
+    mutable epicsMutex diagnosticCountersMutex;
+    caServer & adapter;
+    beaconTimer & beaconTmr;
+    beaconAnomalyGovernor & beaconAnomalyGov;
+    unsigned debugLevel;
+    unsigned nEventsProcessed; 
+    unsigned nEventsPosted; 
+    unsigned ioInProgressCount;
+
+    casEventMask valueEvent; // DBE_VALUE registerEvent("value")
+    casEventMask logEvent;  // DBE_LOG registerEvent("log")
+    casEventMask alarmEvent; // DBE_ALARM registerEvent("alarm")
+    casEventMask propertyEvent;  // DBE_PROPERTY registerEvent("property")
+
+    caStatus attachInterface ( const caNetAddr & addr, bool autoBeaconAddr,
+            bool addConfigAddr );
+
+    virtual void addMCast(const osiSockAddr&);
+
+    void sendBeacon ( ca_uint32_t beaconNo );
+
+    caServerI ( const caServerI & );
+    caServerI & operator = ( const caServerI & );
+
+    friend class beaconAnomalyGovernor;
+    friend class beaconTimer;
+};
+
+
+inline caServer * caServerI::getAdapter()
+{
+    return & this->adapter;
+}
+
+inline caServer * caServerI::operator -> ()
+{
+    return this->getAdapter();
+}
+
+inline void caServerI::setDebugLevel(unsigned debugLevelIn)
+{
+    this->debugLevel = debugLevelIn;
+}
+
+inline casEventMask caServerI::valueEventMask() const
+{
+    return this->valueEvent;
+}
+
+inline casEventMask caServerI::logEventMask() const
+{
+    return this->logEvent;
+}
+
+inline casEventMask caServerI::alarmEventMask() const
+{
+    return this->alarmEvent;
+}
+
+inline casEventMask caServerI::propertyEventMask() const
+{
+    return this->propertyEvent;
+}
+
+inline bool caServerI :: ioIsPending () const
+{
+    return ( ioInProgressCount > 0u );
+}
+
+inline void caServerI :: incrementIOInProgCount ()
+{
+    assert ( ioInProgressCount < UINT_MAX );
+    ioInProgressCount++;
+}
+
+inline void caServerI :: decrementIOInProgCount ()
+{
+    assert ( ioInProgressCount > 0 );
+    ioInProgressCount--;
+    this->ioBlockedList::signal ();
+}
+
+#endif // caServerIh
diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc	2016-12-13 05:25:23
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc	2025-04-30 01:08:02
@@ -288,7 +288,7 @@
 }
 
 caStatus casPVI::installMonitor ( 
-    casMonitor & mon, tsDLList < casMonitor > & monitorList )
+    casMonitor & mon, ::tsDLList < casMonitor > & monitorList )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
     assert ( this->nMonAttached < UINT_MAX );
@@ -304,7 +304,7 @@
 }
 
 casMonitor * casPVI::removeMonitor ( 
-    tsDLList < casMonitor > & list, ca_uint32_t clientIdIn )
+    ::tsDLList < casMonitor > & list, ca_uint32_t clientIdIn )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
     casMonitor * pMon = 0;
@@ -361,8 +361,8 @@
 }
  
 void casPVI::removeChannel ( 
-    chanIntfForPV & chan, tsDLList < casMonitor > & src, 
-    tsDLList < casMonitor > & dest )
+    chanIntfForPV & chan, ::tsDLList < casMonitor > & src, 
+    ::tsDLList < casMonitor > & dest )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
     src.removeAll ( dest );
@@ -376,7 +376,7 @@
     }
 }
 
-void casPVI::clearOutstandingReads ( tsDLList < casAsyncIOI > & ioList )
+void casPVI::clearOutstandingReads ( ::tsDLList < casAsyncIOI > & ioList )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
 
@@ -396,7 +396,7 @@
 	}
 }
 
-void casPVI::destroyAllIO ( tsDLList < casAsyncIOI > & ioList )
+void casPVI::destroyAllIO ( ::tsDLList < casAsyncIOI > & ioList )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
 	while ( casAsyncIOI * pIO = ioList.get() ) {
@@ -408,7 +408,7 @@
 }
 
 void casPVI::installIO ( 
-    tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
+    ::tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
 {
     epicsGuard < epicsMutex > guard ( this->mutex );
     ioList.add ( io );
@@ -417,7 +417,7 @@
 }
 
 void casPVI::uninstallIO ( 
-    tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
+    ::tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
 {
     {
         epicsGuard < epicsMutex > guard ( this->mutex );
diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc-e epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc-e
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc-e	1969-12-31 16:00:00
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.cc-e	2016-12-13 05:25:23
@@ -0,0 +1,545 @@
+/*************************************************************************\
+* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
+*     National Laboratory.
+* Copyright (c) 2002 The Regents of the University of California, as
+*     Operator of Los Alamos National Laboratory.
+* EPICS BASE is distributed subject to a Software License Agreement found
+* in file LICENSE that is included with this distribution. 
+\*************************************************************************/
+/*
+ *      Author  Jeffrey O. Hill
+ *              johill@lanl.gov
+ *              505 665 1831
+ */
+
+#include "epicsGuard.h"
+#include "gddAppTable.h" // EPICS application type table
+#include "gddApps.h"
+#include "dbMapper.h" // EPICS application type table
+#include "errlog.h"
+
+#define epicsExportSharedSymbols
+#include "caServerDefs.h"
+#include "caServerI.h"
+#include "casPVI.h"
+#include "chanIntfForPV.h"
+#include "casAsyncIOI.h"
+#include "casMonitor.h"
+
+casPVI::casPVI ( casPV & intf ) : 
+	pCAS ( NULL ), pPV ( & intf ), nMonAttached ( 0u ), 
+        nIOAttached ( 0u ), deletePending ( false ) {}
+
+casPVI::~casPVI ()
+{
+	//
+	// all channels should have been destroyed 
+    // (otherwise the server tool is yanking the 
+    // PV out from under the server)
+	//
+	casVerify ( this->chanList.count() == 0u );
+
+	//
+	// all outstanding IO should have been deleted
+	// when we destroyed the channels
+	//
+	casVerify ( this->nIOAttached == 0u );
+    if ( this->nIOAttached ) {
+        errlogPrintf ( "The number of IO objected attached is %u\n", this->nIOAttached );
+    }
+
+	//
+	// all monitors should have been deleted
+	// when we destroyed the channels
+	//
+	casVerify ( this->nMonAttached == 0u );
+
+    {
+        epicsGuard < epicsMutex > guard ( this->mutex );
+        this->deletePending = true;
+        if ( this->pPV ) {
+            this->pPV->destroyRequest ();
+        }
+    }
+}
+
+void casPVI::casPVDestroyNotify ()
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    this->pPV = 0;
+    if ( ! this->deletePending ) {
+        // last channel to be destroyed destroys the casPVI
+        tsDLIter < chanIntfForPV > iter = this->chanList.firstIter ();
+        while ( iter.valid() ) {
+            iter->postDestroyEvent ();
+            iter++;
+        }
+    }
+}
+
+//
+// check for none attached and delete self if so
+//
+// this call must be protected by the server's lock
+// ( which also protects channel creation)
+//
+void casPVI::deleteSignal ()
+{
+    bool destroyNeeded = false;
+    {
+        epicsGuard < epicsMutex > guard ( this->mutex );
+
+	    //
+	    // if we are not attached to a server then the
+	    // following steps are not relevant
+	    //
+	    if ( this->pCAS ) {
+		    if ( this->chanList.count() == 0u ) {
+                this->pCAS = NULL;
+                // refresh the table whenever the server reattaches to the PV
+                this->enumStrTbl.clear ();
+                destroyNeeded = true;
+		    }
+	    }
+    }
+
+    if ( destroyNeeded ) {
+		delete this;
+    }
+
+	// !! dont access self after potential delete above !!
+}
+
+caStatus casPVI::attachToServer ( caServerI & cas )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	if ( this->pCAS ) {
+		//
+		// currently we enforce that the PV can be attached to only
+		// one server at a time
+		//
+		if ( this->pCAS != & cas ) {
+			return S_cas_pvAlreadyAttached;
+		}
+	}
+	else {
+		this->pCAS = & cas;
+	}
+	return S_cas_success;
+}
+
+//
+// casPVI::updateEnumStringTable ()
+//
+// fetch string conversion table so that we can perform proper conversion
+// of enumerated PVs to strings during reads
+//
+// what a API complexity nightmare this GDD is
+//
+caStatus casPVI::updateEnumStringTable ( casCtx & ctxIn )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    
+    //
+    // create a gdd with the "enum string table" application type
+    //
+    //	gddArray(int app, aitEnum prim, int dimen, ...);
+    gdd * pTmp = new gddScalar ( gddAppType_enums );
+    if ( pTmp == NULL ) {
+        errMessage ( S_cas_noMemory, 
+            "unable to create gdd for read of application type \"enums\" string"
+            " conversion table for enumerated PV" );
+        return S_cas_noMemory;
+    }
+
+    caStatus status = convertContainerMemberToAtomic ( *pTmp, 
+         gddAppType_enums, MAX_ENUM_STATES );
+    if ( status != S_cas_success ) {
+        pTmp->unreference ();
+        errMessage ( status, 
+            "unable to to config gdd for read of application type \"enums\" string"
+            " conversion table for enumerated PV");
+        return status;
+    }
+
+    //
+    // read the enum string table
+    //
+    status = this->read ( ctxIn, *pTmp );
+    if ( status == S_cas_success ) {
+        updateEnumStringTableAsyncCompletion ( *pTmp );
+	}
+    else if ( status != S_casApp_asyncCompletion && 
+                status != S_casApp_postponeAsyncIO ) {
+        errPrintf ( status, __FILE__, __LINE__,
+            "- unable to read application type \"enums\" "
+            " (string conversion table) from enumerated native type PV \"%s\"", 
+            this->getName() );
+    }
+
+    pTmp->unreference ();
+
+    return status;
+}
+
+void casPVI::updateEnumStringTableAsyncCompletion ( const gdd & resp )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    
+    if ( resp.isContainer() ) {
+        errMessage ( S_cas_badType, 
+            "application type \"enums\" string conversion table for"
+            " enumerated PV was a container (expected vector of strings)" );
+        return;
+    }
+    
+    if  ( resp.dimension() == 0 ) {
+        if ( resp.primitiveType() == aitEnumString ) {
+            aitString *pStr = (aitString *) resp.dataVoid ();
+            if ( ! this->enumStrTbl.setString ( 0, pStr->string() ) ) {
+                errMessage ( S_cas_noMemory, 
+                    "no memory to set enumerated PV string cache" );
+            }
+        }
+        else if ( resp.primitiveType() == aitEnumFixedString ) {
+            aitFixedString *pStr = (aitFixedString *) resp.dataVoid ();
+            if ( ! this->enumStrTbl.setString ( 0, pStr->fixed_string ) ) {
+                errMessage ( S_cas_noMemory, 
+                    "no memory to set enumerated PV string cache" );
+            }
+        }
+        else {
+            errPrintf ( S_cas_badType, __FILE__, __LINE__,
+                "application type \"enums\" string conversion"
+                " table for enumerated PV \"%s\" isnt a string type?",
+                getName() );
+        }
+    }
+    else if ( resp.dimension() == 1 ) {
+        gddStatus gdd_status;
+        aitIndex index, first, count;
+        
+        gdd_status = resp.getBound ( 0, first, count );
+        assert ( gdd_status == 0 );
+
+        //
+        // clear and preallocate the correct amount
+        //
+        this->enumStrTbl.clear ();
+        this->enumStrTbl.reserve ( count );
+
+        if ( resp.primitiveType() == aitEnumString ) {
+            aitString *pStr = (aitString *) resp.dataVoid ();
+            for ( index = 0; index<count; index++ ) {
+                if ( ! this->enumStrTbl.setString ( index, pStr[index].string() ) ) {
+                    errMessage ( S_cas_noMemory, 
+                        "no memory to set enumerated PV string cache" );
+                }
+            }
+        }
+        else if ( resp.primitiveType() == aitEnumFixedString ) {
+            aitFixedString *pStr = (aitFixedString *) resp.dataVoid ();
+            for ( index = 0; index < count; index++ ) {
+                if ( ! this->enumStrTbl.setString ( index, pStr[index].fixed_string ) ) {
+                    errMessage ( S_cas_noMemory, 
+                        "no memory to set enumerated PV string cache" );
+                }
+            }
+        }
+        else {
+            errMessage ( S_cas_badType, 
+                "application type \"enums\" string conversion"
+                " table for enumerated PV isnt a string type?" );
+        }
+    }
+    else {
+        errMessage ( S_cas_badType, 
+            "application type \"enums\" string conversion table"
+            " for enumerated PV was multi-dimensional"
+            " (expected vector of strings)" );
+    }
+}
+
+void casPVI::postEvent ( const casEventMask & select, const gdd & event )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    // if this is a DBE_PROPERTY event for an enum type
+    // update the enum string table
+    if ( (select & this->pCAS->propertyEventMask()).eventsSelected() ) {
+        const gdd *menu = NULL;
+        if ( event.applicationType() == gddAppType_dbr_gr_enum )
+            menu = event.getDD( gddAppTypeIndex_dbr_gr_enum_enums );
+        else if ( event.applicationType() == gddAppType_dbr_ctrl_enum )
+            menu = event.getDD( gddAppTypeIndex_dbr_ctrl_enum_enums );
+        if ( menu )
+            updateEnumStringTableAsyncCompletion( *menu );
+    }
+
+	if ( this->nMonAttached ) {
+        // we are paying some significant locking overhead for
+        // these diagnostic counters
+        this->pCAS->updateEventsPostedCounter ( this->nMonAttached );
+	    tsDLIter < chanIntfForPV > iter = this->chanList.firstIter ();
+        while ( iter.valid () ) {
+		    iter->postEvent ( select, event );
+		    ++iter;
+	    }
+	}
+}
+
+caStatus casPVI::installMonitor ( 
+    casMonitor & mon, tsDLList < casMonitor > & monitorList )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    assert ( this->nMonAttached < UINT_MAX );
+	this->nMonAttached++;
+    // use pv lock to protect channel's monitor list
+	monitorList.add ( mon );
+    if ( this->nMonAttached == 1u && this->pPV ) {
+		return this->pPV->interestRegister ();
+    }
+    else {
+		return S_cas_success;
+    }
+}
+
+casMonitor * casPVI::removeMonitor ( 
+    tsDLList < casMonitor > & list, ca_uint32_t clientIdIn )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    casMonitor * pMon = 0;
+	//
+	// (it is reasonable to do a linear search here because
+	// sane clients will require only one or two monitors 
+	// per channel)
+	//
+	tsDLIter < casMonitor > iter = list.firstIter ();
+    while ( iter.valid () ) {
+		if ( iter->matchingClientId ( clientIdIn ) ) {
+            list.remove ( *iter.pointer () );
+            assert ( this->nMonAttached > 0 );
+	        this->nMonAttached--;
+            pMon = iter.pointer ();
+            break;
+		}
+		iter++;
+	}
+    if ( this->nMonAttached == 0u && this->pPV ) {
+        this->pPV->interestDelete ();
+    }
+    return pMon;
+}
+
+caServer *casPVI::getExtServer () const
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	if ( this->pCAS ) {
+		return this->pCAS->getAdapter ();
+	}
+	else {
+		return NULL;
+	}
+}
+
+void casPVI::show ( unsigned level )  const
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	printf ( "CA Server PV: nChanAttached=%u nMonAttached=%u nIOAttached=%u\n",
+		this->chanList.count(), this->nMonAttached, this->nIOAttached );
+	if ( level >= 1u ) {
+		printf ( "\tBest external type = %d\n", this->bestExternalType() );
+	}
+	if ( level >= 2u ) {
+        this->pPV->show ( level - 2u );
+	}
+}
+
+void casPVI::installChannel ( chanIntfForPV & chan )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	this->chanList.add ( chan );
+}
+ 
+void casPVI::removeChannel ( 
+    chanIntfForPV & chan, tsDLList < casMonitor > & src, 
+    tsDLList < casMonitor > & dest )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    src.removeAll ( dest );
+    if ( dest.count() ) {
+        assert ( this->nMonAttached >= dest.count() );
+        this->nMonAttached -= dest.count ();
+    }
+	this->chanList.remove ( chan );
+    if ( this->nMonAttached == 0u && this->pPV ) {
+        this->pPV->interestDelete ();
+    }
+}
+
+void casPVI::clearOutstandingReads ( tsDLList < casAsyncIOI > & ioList )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+
+    // cancel any pending asynchronous IO 
+	tsDLIter < casAsyncIOI > iterIO = 
+        ioList.firstIter ();
+	while ( iterIO.valid () ) {
+		tsDLIter < casAsyncIOI > tmp = iterIO;
+		++tmp;
+        if ( iterIO->oneShotReadOP () ) {
+            ioList.remove ( *iterIO );
+		    delete iterIO.pointer ();
+            assert ( this->nIOAttached != 0 );
+            this->nIOAttached--;
+        }
+		iterIO = tmp;
+	}
+}
+
+void casPVI::destroyAllIO ( tsDLList < casAsyncIOI > & ioList )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	while ( casAsyncIOI * pIO = ioList.get() ) {
+        pIO->removeFromEventQueue ();
+		delete pIO;
+        assert ( this->nIOAttached != 0 );
+        this->nIOAttached--;
+	}
+}
+
+void casPVI::installIO ( 
+    tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    ioList.add ( io );
+    assert ( this->nIOAttached != UINT_MAX );
+    this->nIOAttached++;
+}
+
+void casPVI::uninstallIO ( 
+    tsDLList < casAsyncIOI > & ioList, casAsyncIOI & io )
+{
+    {
+        epicsGuard < epicsMutex > guard ( this->mutex );
+        ioList.remove ( io );
+        assert ( this->nIOAttached != 0 );
+        this->nIOAttached--;
+    }
+	this->ioBlockedList::signal();
+}
+
+caStatus  casPVI::bestDBRType ( unsigned & dbrType )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+	aitEnum bestAIT = this->bestExternalType ();
+    if ( bestAIT == aitEnumInvalid || bestAIT < 0 ) {
+		return S_cas_badType;
+    }
+    unsigned aitIndex = static_cast < unsigned > ( bestAIT );
+	if ( aitIndex >= sizeof ( gddAitToDbr ) / sizeof ( gddAitToDbr[0] ) ) {
+		return S_cas_badType;
+    }
+	dbrType = gddAitToDbr[bestAIT];
+	return S_cas_success;
+}
+
+caStatus casPVI::read ( const casCtx & ctx, gdd & prototype )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        caStatus status = this->pPV->beginTransaction ();
+        if ( status != S_casApp_success ) {
+            return status;
+        }
+        status = this->pPV->read ( ctx, prototype );
+        this->pPV->endTransaction ();
+        return status;
+    }
+    else {
+        return S_cas_disconnect;
+    }
+}
+
+caStatus casPVI::write ( const casCtx & ctx, const gdd & value )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        caStatus status = this->pPV->beginTransaction ();
+        if ( status != S_casApp_success ) {
+            return status;
+        }
+        status = this->pPV->write ( ctx, value );
+        this->pPV->endTransaction ();
+        return status;
+    }
+    else {
+        return S_cas_disconnect;
+    }
+}
+
+caStatus casPVI::writeNotify ( const casCtx & ctx, const gdd & value )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        caStatus status = this->pPV->beginTransaction ();
+        if ( status != S_casApp_success ) {
+            return status;
+        }
+        status = this->pPV->writeNotify ( ctx, value );
+        this->pPV->endTransaction ();
+        return status;
+    }
+    else {
+        return S_cas_disconnect;
+    }
+}
+
+casChannel * casPVI::createChannel ( const casCtx & ctx,
+    const char * const pUserName, const char * const pHostName )
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        return this->pPV->createChannel ( ctx, pUserName, pHostName );
+    }
+    else {
+        return 0;
+    }
+}
+
+aitEnum casPVI::bestExternalType () const
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        return this->pPV->bestExternalType ();
+    }
+    else {
+        return aitEnumInvalid;
+    }
+}
+
+// CA only does 1D arrays for now 
+aitIndex casPVI::nativeCount () 
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+	    if ( this->pPV->maxDimension() == 0u ) {
+		    return 1u; // scalar
+	    }
+	    return this->pPV->maxBound ( 0u );
+    }
+    else {
+        return S_cas_disconnect;
+    }
+}
+
+const char * casPVI::getName () const
+{
+    epicsGuard < epicsMutex > guard ( this->mutex );
+    if ( this->pPV ) {
+        return this->pPV->getName ();
+    }
+    else {
+        return "<disconnected>";
+    }
+}
+
diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h	2016-12-13 05:25:23
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h	2025-04-30 01:08:02
@@ -49,21 +49,21 @@
     caStatus attachToServer ( caServerI & cas );
     aitIndex nativeCount ();
     bool ioIsPending () const;
-	void clearOutstandingReads ( tsDLList < class casAsyncIOI > &);
+	void clearOutstandingReads ( ::tsDLList < class casAsyncIOI > &);
     void destroyAllIO ( 
-        tsDLList < casAsyncIOI > & );
+        ::tsDLList < casAsyncIOI > & );
     void installIO (
-        tsDLList < casAsyncIOI > &, casAsyncIOI & );
+        ::tsDLList < casAsyncIOI > &, casAsyncIOI & );
     void uninstallIO ( 
-        tsDLList < casAsyncIOI > &, casAsyncIOI & );
+        ::tsDLList < casAsyncIOI > &, casAsyncIOI & );
     void installChannel ( chanIntfForPV & chan );
     void removeChannel ( 
-        chanIntfForPV & chan, tsDLList < casMonitor > & src,
-        tsDLList < casMonitor > & dest );
+        chanIntfForPV & chan, ::tsDLList < casMonitor > & src,
+        ::tsDLList < casMonitor > & dest );
     caStatus installMonitor ( 
-        casMonitor & mon, tsDLList < casMonitor > & monitorList );
+        casMonitor & mon, ::tsDLList < casMonitor > & monitorList );
     casMonitor * removeMonitor ( 
-        tsDLList < casMonitor > & list, ca_uint32_t clientIdIn );
+        ::tsDLList < casMonitor > & list, ca_uint32_t clientIdIn );
     void deleteSignal ();
     void postEvent ( const casEventMask & select, const gdd & event );
     caServer * getExtServer () const;
@@ -84,7 +84,7 @@
 
 private:
     mutable epicsMutex mutex;
-    tsDLList < chanIntfForPV > chanList;
+    ::tsDLList < chanIntfForPV > chanList;
     gddEnumStringTable enumStrTbl;
     caServerI * pCAS;
     casPV * pPV;
diff -ruN orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h-e epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h-e
--- orig/epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h-e	1969-12-31 16:00:00
+++ epics-base-R3.15.5/src/ca/legacy/pcas/generic/casPVI.h-e	2016-12-13 05:25:23
@@ -0,0 +1,120 @@
+/*************************************************************************\
+* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
+*     National Laboratory.
+* Copyright (c) 2002 The Regents of the University of California, as
+*     Operator of Los Alamos National Laboratory.
+* EPICS BASE Versions 3.13.7
+* and higher are distributed subject to a Software License Agreement found
+* in file LICENSE that is included with this distribution. 
+\*************************************************************************/
+/*
+ *      Author  Jeffrey O. Hill
+ *              johill@lanl.gov
+ *              505 665 1831
+ */
+
+#ifndef casPVIh
+#define casPVIh
+
+#ifdef epicsExportSharedSymbols
+#   define epicsExportSharedSymbols_casPVIh
+#   undef epicsExportSharedSymbols
+#endif
+
+// external headers included here
+#include "tsSLList.h"
+#include "epicsMutex.h"
+#include "caProto.h"
+
+#ifdef epicsExportSharedSymbols_casPVIh
+#   define epicsExportSharedSymbols
+#   include "shareLib.h"
+#endif
+
+#include "casdef.h"
+#include "ioBlocked.h"
+
+class chanIntfForPV;
+class caServerI;
+class casMonitor;
+
+class casPVI : 
+    public tsSLNode < casPVI >, // server resource table installation 
+    public ioBlockedList // list of clients io blocked on this pv
+{
+public:
+    casPVI ( casPV & );
+    epicsShareFunc virtual ~casPVI (); 
+    caServerI * getPCAS () const;
+    caStatus attachToServer ( caServerI & cas );
+    aitIndex nativeCount ();
+    bool ioIsPending () const;
+	void clearOutstandingReads ( tsDLList < class casAsyncIOI > &);
+    void destroyAllIO ( 
+        tsDLList < casAsyncIOI > & );
+    void installIO (
+        tsDLList < casAsyncIOI > &, casAsyncIOI & );
+    void uninstallIO ( 
+        tsDLList < casAsyncIOI > &, casAsyncIOI & );
+    void installChannel ( chanIntfForPV & chan );
+    void removeChannel ( 
+        chanIntfForPV & chan, tsDLList < casMonitor > & src,
+        tsDLList < casMonitor > & dest );
+    caStatus installMonitor ( 
+        casMonitor & mon, tsDLList < casMonitor > & monitorList );
+    casMonitor * removeMonitor ( 
+        tsDLList < casMonitor > & list, ca_uint32_t clientIdIn );
+    void deleteSignal ();
+    void postEvent ( const casEventMask & select, const gdd & event );
+    caServer * getExtServer () const;
+    caStatus bestDBRType ( unsigned & dbrType );
+    const gddEnumStringTable & enumStringTable () const;
+    caStatus updateEnumStringTable ( casCtx & );
+    void updateEnumStringTableAsyncCompletion ( const gdd & resp );
+    casPV * apiPointer (); // retuns NULL if casPVI isnt a base of casPV
+    void show ( unsigned level ) const;
+    caStatus read ( const casCtx & ctx, gdd & prototype );
+    caStatus write ( const casCtx & ctx, const gdd & value );
+    caStatus writeNotify ( const casCtx & ctx, const gdd & value );
+    casChannel * createChannel ( const casCtx & ctx,
+        const char * const pUserName, const char * const pHostName );
+    aitEnum bestExternalType () const;
+    const char * getName () const;
+    void casPVDestroyNotify ();
+
+private:
+    mutable epicsMutex mutex;
+    tsDLList < chanIntfForPV > chanList;
+    gddEnumStringTable enumStrTbl;
+    caServerI * pCAS;
+    casPV * pPV;
+    unsigned nMonAttached;
+    unsigned nIOAttached;
+    bool deletePending;
+
+	casPVI ( const casPVI & );
+	casPVI & operator = ( const casPVI & );
+};
+
+inline caServerI * casPVI::getPCAS() const
+{
+	return this->pCAS;
+}
+
+inline const gddEnumStringTable & casPVI::enumStringTable () const
+{
+    return this->enumStrTbl;
+}
+
+inline casPV * casPVI::apiPointer ()
+{
+    return this->pPV;
+}
+
+inline bool casPVI :: ioIsPending () const
+{
+    return this->nIOAttached > 0u;
+}
+
+#endif // casPVIh
+
